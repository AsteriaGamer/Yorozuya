// This file auto generated by plugin for ida pro. Generated code only for x64. Please, dont change manually
#pragma once

#include "./common/common.h"
#include "CMoveMapLimitInfoList.hpp"
#include "CMoveMapLimitRightInfoList.hpp"
#include "CPlayer.hpp"


START_ATF_NAMESPACE
    struct CMoveMapLimitManager
    {
        CMoveMapLimitRightInfoList m_kRightInfo;
        CMoveMapLimitInfoList m_kLimitInfo;
    public:
        CMoveMapLimitManager()
        {
            using org_ptr = void (WINAPIV*)(struct CMoveMapLimitManager*);
            (org_ptr(0x1403a1d10L))(this);
        };
        void ctor_CMoveMapLimitManager()
        {
            using org_ptr = void (WINAPIV*)(struct CMoveMapLimitManager*);
            (org_ptr(0x1403a1d10L))(this);
        };
        void CreateComplete(struct CPlayer* pkPlayer)
        {
            using org_ptr = void (WINAPIV*)(struct CMoveMapLimitManager*, struct CPlayer*);
            (org_ptr(0x1403a1910L))(this, pkPlayer);
        };
        static void Destroy()
        {
            using org_ptr = void (WINAPIV*)();
            (org_ptr(0x1403a16b0L))();
        };
        bool Init()
        {
            using org_ptr = bool (WINAPIV*)(struct CMoveMapLimitManager*);
            return (org_ptr(0x1403a1720L))(this);
        };
        static struct CMoveMapLimitManager* Instance()
        {
            using org_ptr = struct CMoveMapLimitManager* (WINAPIV*)();
            return (org_ptr(0x1403a15f0L))();
        };
        void Load(struct CPlayer* pkPlayer)
        {
            using org_ptr = void (WINAPIV*)(struct CMoveMapLimitManager*, struct CPlayer*);
            (org_ptr(0x1403a1830L))(this, pkPlayer);
        };
        void LogIn(struct CPlayer* pkPlayer)
        {
            using org_ptr = void (WINAPIV*)(struct CMoveMapLimitManager*, struct CPlayer*);
            (org_ptr(0x1403a18a0L))(this, pkPlayer);
        };
        void LogOut(struct CPlayer* pkPlayer)
        {
            using org_ptr = void (WINAPIV*)(struct CMoveMapLimitManager*, struct CPlayer*);
            (org_ptr(0x1403a1960L))(this, pkPlayer);
        };
        void Loop()
        {
            using org_ptr = void (WINAPIV*)(struct CMoveMapLimitManager*);
            (org_ptr(0x1403a1b40L))(this);
        };
        bool MoveLimitMapZoneRequest(int iUserInx, char* pRequest)
        {
            using org_ptr = bool (WINAPIV*)(struct CMoveMapLimitManager*, int, char*);
            return (org_ptr(0x1403a1a60L))(this, iUserInx, pRequest);
        };
        char Request(int iLimitType, int iRequetType, int iMapInx, unsigned int dwStoreRecordIndex, int iUserInx, char* pRequest)
        {
            using org_ptr = char (WINAPIV*)(struct CMoveMapLimitManager*, int, int, int, unsigned int, int, char*);
            return (org_ptr(0x1403a19d0L))(this, iLimitType, iRequetType, iMapInx, dwStoreRecordIndex, iUserInx, pRequest);
        };
        char RequestElanMapUserForceMoveHQ()
        {
            using org_ptr = char (WINAPIV*)(struct CMoveMapLimitManager*);
            return (org_ptr(0x140284700L))(this);
        };
        ~CMoveMapLimitManager()
        {
            using org_ptr = void (WINAPIV*)(struct CMoveMapLimitManager*);
            (org_ptr(0x1403a1f10L))(this);
        };
        void dtor_CMoveMapLimitManager()
        {
            using org_ptr = void (WINAPIV*)(struct CMoveMapLimitManager*);
            (org_ptr(0x1403a1f10L))(this);
        };
    };
END_ATF_NAMESPACE
