// This file auto generated by plugin for ida pro. Generated code only for x64. Please, dont change manually
#pragma once

#include "./common/common.h"
#include "std__pair_info.hpp"


START_ATF_NAMESPACE
    namespace std
    {
        namespace detail
        {
            static info::std__pairctor_pair2_ptr std__pairctor_pair2_next(nullptr);
            static info::std__pairctor_pair2_clbk std__pairctor_pair2_user(nullptr);
            
            static void std__pairctor_pair2_wrapper(struct std::pair<int,int>* _this, int* _Val1, int* _Val2)
            {
               std__pairctor_pair2_user(_this, _Val1, _Val2);
            };
            
            static hook_record pair<int,int>_functions[] = {
            {   (LPVOID)0x14019af80L,
                (LPVOID *)&std__pairctor_pair2_user,
                (LPVOID *)&std__pairctor_pair2_next,
                (LPVOID)cast_pointer_function(std__pairctor_pair2_wrapper),
                (LPVOID)cast_pointer_function((void(std::pair<int,int>::*)(int*, int*))&std::pair<int,int>::ctor_pair) },
            
            };
            
        }; // static end namespace detail
    }; // end namespace std
END_ATF_NAMESPACE
#include "std__pair_info.hpp"


START_ATF_NAMESPACE
    namespace std
    {
        namespace detail
        {
            static info::std__pairctor_pair2_ptr std__pairctor_pair2_next(nullptr);
            static info::std__pairctor_pair2_clbk std__pairctor_pair2_user(nullptr);
            static info::std__pairctor_pair4_ptr std__pairctor_pair4_next(nullptr);
            static info::std__pairctor_pair4_clbk std__pairctor_pair4_user(nullptr);
            
            static void std__pairctor_pair2_wrapper(struct std::pair<int,CNationCodeStr *>* _this, int* _Val1, struct CNationCodeStr** _Val2)
            {
               std__pairctor_pair2_user(_this, _Val1, _Val2);
            };
            static void std__pairctor_pair4_wrapper(struct std::pair<int,CNationCodeStr *>* _this, struct std::pair<int const ,CNationCodeStr *>* _Right)
            {
               std__pairctor_pair4_user(_this, _Right);
            };
            
            static hook_record pair<int,CNationCodeStr *>_functions[] = {
            {   (LPVOID)0x140210f40L,
                (LPVOID *)&std__pairctor_pair2_user,
                (LPVOID *)&std__pairctor_pair2_next,
                (LPVOID)cast_pointer_function(std__pairctor_pair2_wrapper),
                (LPVOID)cast_pointer_function((void(std::pair<int,CNationCodeStr *>::*)(int*, struct CNationCodeStr**))&std::pair<int,CNationCodeStr *>::ctor_pair) },
            {   (LPVOID)0x14020a670L,
                (LPVOID *)&std__pairctor_pair4_user,
                (LPVOID *)&std__pairctor_pair4_next,
                (LPVOID)cast_pointer_function(std__pairctor_pair4_wrapper),
                (LPVOID)cast_pointer_function((void(std::pair<int,CNationCodeStr *>::*)(struct std::pair<int const ,CNationCodeStr *>*))&std::pair<int,CNationCodeStr *>::ctor_pair) },
            
            };
            
        }; // static end namespace detail
    }; // end namespace std
END_ATF_NAMESPACE
#include "std__pair_info.hpp"


START_ATF_NAMESPACE
    namespace std
    {
        namespace detail
        {
            static info::std__pairctor_pair2_ptr std__pairctor_pair2_next(nullptr);
            static info::std__pairctor_pair2_clbk std__pairctor_pair2_user(nullptr);
            
            static void std__pairctor_pair2_wrapper(struct std::pair<int,CAsyncLogInfo *>* _this, struct std::pair<int const ,CAsyncLogInfo *>* _Right)
            {
               std__pairctor_pair2_user(_this, _Right);
            };
            
            static hook_record pair<int,CAsyncLogInfo *>_functions[] = {
            {   (LPVOID)0x1403c7590L,
                (LPVOID *)&std__pairctor_pair2_user,
                (LPVOID *)&std__pairctor_pair2_next,
                (LPVOID)cast_pointer_function(std__pairctor_pair2_wrapper),
                (LPVOID)cast_pointer_function((void(std::pair<int,CAsyncLogInfo *>::*)(struct std::pair<int const ,CAsyncLogInfo *>*))&std::pair<int,CAsyncLogInfo *>::ctor_pair) },
            
            };
            
        }; // static end namespace detail
    }; // end namespace std
END_ATF_NAMESPACE
#include "std__pair_info.hpp"


START_ATF_NAMESPACE
    namespace std
    {
        namespace detail
        {
            static info::std__pairctor_pair2_ptr std__pairctor_pair2_next(nullptr);
            static info::std__pairctor_pair2_clbk std__pairctor_pair2_user(nullptr);
            static info::std__pairctor_pair4_ptr std__pairctor_pair4_next(nullptr);
            static info::std__pairctor_pair4_clbk std__pairctor_pair4_user(nullptr);
            
            static void std__pairctor_pair2_wrapper(struct std::pair<int,CNationSettingFactory *>* _this, int* _Val1, struct CNationSettingFactory** _Val2)
            {
               std__pairctor_pair2_user(_this, _Val1, _Val2);
            };
            static void std__pairctor_pair4_wrapper(struct std::pair<int,CNationSettingFactory *>* _this, struct std::pair<int const ,CNationSettingFactory *>* _Right)
            {
               std__pairctor_pair4_user(_this, _Right);
            };
            
            static hook_record pair<int,CNationSettingFactory *>_functions[] = {
            {   (LPVOID)0x140221e90L,
                (LPVOID *)&std__pairctor_pair2_user,
                (LPVOID *)&std__pairctor_pair2_next,
                (LPVOID)cast_pointer_function(std__pairctor_pair2_wrapper),
                (LPVOID)cast_pointer_function((void(std::pair<int,CNationSettingFactory *>::*)(int*, struct CNationSettingFactory**))&std::pair<int,CNationSettingFactory *>::ctor_pair) },
            {   (LPVOID)0x14022adf0L,
                (LPVOID *)&std__pairctor_pair4_user,
                (LPVOID *)&std__pairctor_pair4_next,
                (LPVOID)cast_pointer_function(std__pairctor_pair4_wrapper),
                (LPVOID)cast_pointer_function((void(std::pair<int,CNationSettingFactory *>::*)(struct std::pair<int const ,CNationSettingFactory *>*))&std::pair<int,CNationSettingFactory *>::ctor_pair) },
            
            };
            
        }; // static end namespace detail
    }; // end namespace std
END_ATF_NAMESPACE
