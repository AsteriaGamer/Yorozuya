// This file auto generated by plugin for ida pro. Generated code only for x64. Please, dont change manually
#pragma once

#include "./common/common.h"
#include "CMoveMapLimitRightPortal_info.hpp"


START_ATF_NAMESPACE
    namespace detail
    {
        static info::CMoveMapLimitRightPortalctor_CMoveMapLimitRightPortal2_ptr CMoveMapLimitRightPortalctor_CMoveMapLimitRightPortal2_next(nullptr);
        static info::CMoveMapLimitRightPortalctor_CMoveMapLimitRightPortal2_clbk CMoveMapLimitRightPortalctor_CMoveMapLimitRightPortal2_user(nullptr);
        static info::CMoveMapLimitRightPortalCreateComplete4_ptr CMoveMapLimitRightPortalCreateComplete4_next(nullptr);
        static info::CMoveMapLimitRightPortalCreateComplete4_clbk CMoveMapLimitRightPortalCreateComplete4_user(nullptr);
        static info::CMoveMapLimitRightPortalIsHaveRight6_ptr CMoveMapLimitRightPortalIsHaveRight6_next(nullptr);
        static info::CMoveMapLimitRightPortalIsHaveRight6_clbk CMoveMapLimitRightPortalIsHaveRight6_user(nullptr);
        static info::CMoveMapLimitRightPortalLoad8_ptr CMoveMapLimitRightPortalLoad8_next(nullptr);
        static info::CMoveMapLimitRightPortalLoad8_clbk CMoveMapLimitRightPortalLoad8_user(nullptr);
        static info::CMoveMapLimitRightPortalLogOut10_ptr CMoveMapLimitRightPortalLogOut10_next(nullptr);
        static info::CMoveMapLimitRightPortalLogOut10_clbk CMoveMapLimitRightPortalLogOut10_user(nullptr);
        static info::CMoveMapLimitRightPortalSetFlag12_ptr CMoveMapLimitRightPortalSetFlag12_next(nullptr);
        static info::CMoveMapLimitRightPortalSetFlag12_clbk CMoveMapLimitRightPortalSetFlag12_user(nullptr);
        
        static void CMoveMapLimitRightPortalctor_CMoveMapLimitRightPortal2_wrapper(struct CMoveMapLimitRightPortal* _this, int iType)
        {
           CMoveMapLimitRightPortalctor_CMoveMapLimitRightPortal2_user(_this, iType, CMoveMapLimitRightPortalctor_CMoveMapLimitRightPortal2_next);
        };
        static void CMoveMapLimitRightPortalCreateComplete4_wrapper(struct CMoveMapLimitRightPortal* _this, struct CPlayer* pkPlayer)
        {
           CMoveMapLimitRightPortalCreateComplete4_user(_this, pkPlayer, CMoveMapLimitRightPortalCreateComplete4_next);
        };
        static bool CMoveMapLimitRightPortalIsHaveRight6_wrapper(struct CMoveMapLimitRightPortal* _this)
        {
           return CMoveMapLimitRightPortalIsHaveRight6_user(_this, CMoveMapLimitRightPortalIsHaveRight6_next);
        };
        static void CMoveMapLimitRightPortalLoad8_wrapper(struct CMoveMapLimitRightPortal* _this, struct CPlayer* pkPlayer)
        {
           CMoveMapLimitRightPortalLoad8_user(_this, pkPlayer, CMoveMapLimitRightPortalLoad8_next);
        };
        static void CMoveMapLimitRightPortalLogOut10_wrapper(struct CMoveMapLimitRightPortal* _this, struct CPlayer* pkPlayer)
        {
           CMoveMapLimitRightPortalLogOut10_user(_this, pkPlayer, CMoveMapLimitRightPortalLogOut10_next);
        };
        static void CMoveMapLimitRightPortalSetFlag12_wrapper(struct CMoveMapLimitRightPortal* _this, int iType, bool bFlag)
        {
           CMoveMapLimitRightPortalSetFlag12_user(_this, iType, bFlag, CMoveMapLimitRightPortalSetFlag12_next);
        };
        
        static hook_record CMoveMapLimitRightPortal_functions[] = {
        {   (LPVOID)0x1403ac7f0L,
            (LPVOID *)&CMoveMapLimitRightPortalctor_CMoveMapLimitRightPortal2_user,
            (LPVOID *)&CMoveMapLimitRightPortalctor_CMoveMapLimitRightPortal2_next,
            (LPVOID)cast_pointer_function(CMoveMapLimitRightPortalctor_CMoveMapLimitRightPortal2_wrapper),
            (LPVOID)cast_pointer_function((void(CMoveMapLimitRightPortal::*)(int))&CMoveMapLimitRightPortal::ctor_CMoveMapLimitRightPortal) },
        {   (LPVOID)0x1403ac890L,
            (LPVOID *)&CMoveMapLimitRightPortalCreateComplete4_user,
            (LPVOID *)&CMoveMapLimitRightPortalCreateComplete4_next,
            (LPVOID)cast_pointer_function(CMoveMapLimitRightPortalCreateComplete4_wrapper),
            (LPVOID)cast_pointer_function((void(CMoveMapLimitRightPortal::*)(struct CPlayer*))&CMoveMapLimitRightPortal::CreateComplete) },
        {   (LPVOID)0x1403ac6a0L,
            (LPVOID *)&CMoveMapLimitRightPortalIsHaveRight6_user,
            (LPVOID *)&CMoveMapLimitRightPortalIsHaveRight6_next,
            (LPVOID)cast_pointer_function(CMoveMapLimitRightPortalIsHaveRight6_wrapper),
            (LPVOID)cast_pointer_function((bool(CMoveMapLimitRightPortal::*)())&CMoveMapLimitRightPortal::IsHaveRight) },
        {   (LPVOID)0x1403ac860L,
            (LPVOID *)&CMoveMapLimitRightPortalLoad8_user,
            (LPVOID *)&CMoveMapLimitRightPortalLoad8_next,
            (LPVOID)cast_pointer_function(CMoveMapLimitRightPortalLoad8_wrapper),
            (LPVOID)cast_pointer_function((void(CMoveMapLimitRightPortal::*)(struct CPlayer*))&CMoveMapLimitRightPortal::Load) },
        {   (LPVOID)0x1403ac940L,
            (LPVOID *)&CMoveMapLimitRightPortalLogOut10_user,
            (LPVOID *)&CMoveMapLimitRightPortalLogOut10_next,
            (LPVOID)cast_pointer_function(CMoveMapLimitRightPortalLogOut10_wrapper),
            (LPVOID)cast_pointer_function((void(CMoveMapLimitRightPortal::*)(struct CPlayer*))&CMoveMapLimitRightPortal::LogOut) },
        {   (LPVOID)0x1403ac790L,
            (LPVOID *)&CMoveMapLimitRightPortalSetFlag12_user,
            (LPVOID *)&CMoveMapLimitRightPortalSetFlag12_next,
            (LPVOID)cast_pointer_function(CMoveMapLimitRightPortalSetFlag12_wrapper),
            (LPVOID)cast_pointer_function((void(CMoveMapLimitRightPortal::*)(int, bool))&CMoveMapLimitRightPortal::SetFlag) },
        
        };
        
    }; // static end namespace detail
END_ATF_NAMESPACE
