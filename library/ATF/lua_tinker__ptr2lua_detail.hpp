// This file auto generated by plugin for ida pro. Generated code only for x64. Please, dont change manually
#pragma once

#include "./common/common.h"
#include "lua_tinker__ptr2lua_info.hpp"


START_ATF_NAMESPACE
    namespace lua_tinker
    {
        namespace detail
        {
            info::lua_tinker__ptr2luainvoke2_ptr lua_tinker__ptr2luainvoke2_next(nullptr);
            info::lua_tinker__ptr2luainvoke2_clbk lua_tinker__ptr2luainvoke2_user(nullptr);
            
            void lua_tinker__ptr2luainvoke2_wrapper(lua_State* L, struct CMonster* input)
            {
               lua_tinker__ptr2luainvoke2_user(L, input);
            };
            
            hook_record ptr2lua<CMonster>_functions[] = {
            {   (LPVOID)0x14040b670L,
                (LPVOID *)&lua_tinker__ptr2luainvoke2_user,
                (LPVOID *)&lua_tinker__ptr2luainvoke2_next,
                (LPVOID)cast_pointer_function(lua_tinker__ptr2luainvoke2_wrapper),
                (LPVOID)cast_pointer_function((void(lua_tinker::ptr2lua<CMonster>::*)(lua_State*, struct CMonster*))&lua_tinker::ptr2lua<CMonster>::invoke) },
            
            };
            
        }; // end namespace detail
    }; // end namespace lua_tinker
END_ATF_NAMESPACE
#include "lua_tinker__ptr2lua_info.hpp"


START_ATF_NAMESPACE
    namespace lua_tinker
    {
        namespace detail
        {
            info::lua_tinker__ptr2luainvoke2_ptr lua_tinker__ptr2luainvoke2_next(nullptr);
            info::lua_tinker__ptr2luainvoke2_clbk lua_tinker__ptr2luainvoke2_user(nullptr);
            
            void lua_tinker__ptr2luainvoke2_wrapper(lua_State* L, struct CLuaSignalReActor* input)
            {
               lua_tinker__ptr2luainvoke2_user(L, input);
            };
            
            hook_record ptr2lua<CLuaSignalReActor>_functions[] = {
            {   (LPVOID)0x14040b450L,
                (LPVOID *)&lua_tinker__ptr2luainvoke2_user,
                (LPVOID *)&lua_tinker__ptr2luainvoke2_next,
                (LPVOID)cast_pointer_function(lua_tinker__ptr2luainvoke2_wrapper),
                (LPVOID)cast_pointer_function((void(lua_tinker::ptr2lua<CLuaSignalReActor>::*)(lua_State*, struct CLuaSignalReActor*))&lua_tinker::ptr2lua<CLuaSignalReActor>::invoke) },
            
            };
            
        }; // end namespace detail
    }; // end namespace lua_tinker
END_ATF_NAMESPACE
#include "lua_tinker__ptr2lua_info.hpp"


START_ATF_NAMESPACE
    namespace lua_tinker
    {
        namespace detail
        {
            info::lua_tinker__ptr2luainvoke2_ptr lua_tinker__ptr2luainvoke2_next(nullptr);
            info::lua_tinker__ptr2luainvoke2_clbk lua_tinker__ptr2luainvoke2_user(nullptr);
            
            void lua_tinker__ptr2luainvoke2_wrapper(lua_State* L, struct CLuaEventMgr* input)
            {
               lua_tinker__ptr2luainvoke2_user(L, input);
            };
            
            hook_record ptr2lua<CLuaEventMgr>_functions[] = {
            {   (LPVOID)0x14040b560L,
                (LPVOID *)&lua_tinker__ptr2luainvoke2_user,
                (LPVOID *)&lua_tinker__ptr2luainvoke2_next,
                (LPVOID)cast_pointer_function(lua_tinker__ptr2luainvoke2_wrapper),
                (LPVOID)cast_pointer_function((void(lua_tinker::ptr2lua<CLuaEventMgr>::*)(lua_State*, struct CLuaEventMgr*))&lua_tinker::ptr2lua<CLuaEventMgr>::invoke) },
            
            };
            
        }; // end namespace detail
    }; // end namespace lua_tinker
END_ATF_NAMESPACE
#include "lua_tinker__ptr2lua_info.hpp"


START_ATF_NAMESPACE
    namespace lua_tinker
    {
        namespace detail
        {
            info::lua_tinker__ptr2luainvoke2_ptr lua_tinker__ptr2luainvoke2_next(nullptr);
            info::lua_tinker__ptr2luainvoke2_clbk lua_tinker__ptr2luainvoke2_user(nullptr);
            
            void lua_tinker__ptr2luainvoke2_wrapper(lua_State* L, struct CLuaEventNode* input)
            {
               lua_tinker__ptr2luainvoke2_user(L, input);
            };
            
            hook_record ptr2lua<CLuaEventNode>_functions[] = {
            {   (LPVOID)0x140404b30L,
                (LPVOID *)&lua_tinker__ptr2luainvoke2_user,
                (LPVOID *)&lua_tinker__ptr2luainvoke2_next,
                (LPVOID)cast_pointer_function(lua_tinker__ptr2luainvoke2_wrapper),
                (LPVOID)cast_pointer_function((void(lua_tinker::ptr2lua<CLuaEventNode>::*)(lua_State*, struct CLuaEventNode*))&lua_tinker::ptr2lua<CLuaEventNode>::invoke) },
            
            };
            
        }; // end namespace detail
    }; // end namespace lua_tinker
END_ATF_NAMESPACE
#include "lua_tinker__ptr2lua_info.hpp"


START_ATF_NAMESPACE
    namespace lua_tinker
    {
        namespace detail
        {
            info::lua_tinker__ptr2luainvoke2_ptr lua_tinker__ptr2luainvoke2_next(nullptr);
            info::lua_tinker__ptr2luainvoke2_clbk lua_tinker__ptr2luainvoke2_user(nullptr);
            
            void lua_tinker__ptr2luainvoke2_wrapper(lua_State* L, struct CLuaScript* input)
            {
               lua_tinker__ptr2luainvoke2_user(L, input);
            };
            
            hook_record ptr2lua<CLuaScript>_functions[] = {
            {   (LPVOID)0x140403050L,
                (LPVOID *)&lua_tinker__ptr2luainvoke2_user,
                (LPVOID *)&lua_tinker__ptr2luainvoke2_next,
                (LPVOID)cast_pointer_function(lua_tinker__ptr2luainvoke2_wrapper),
                (LPVOID)cast_pointer_function((void(lua_tinker::ptr2lua<CLuaScript>::*)(lua_State*, struct CLuaScript*))&lua_tinker::ptr2lua<CLuaScript>::invoke) },
            
            };
            
        }; // end namespace detail
    }; // end namespace lua_tinker
END_ATF_NAMESPACE
