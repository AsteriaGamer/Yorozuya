// This file auto generated by plugin for ida pro. Generated code only for x64. Please, dont change manually
#pragma once

#include "./common/common.h"
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<INI_Section *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<INI_Section *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<INI_Key *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<INI_Key *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<ScheduleMSG *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<ScheduleMSG *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CGuildRoomInfo>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CGuildRoomInfo>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<RoomCharInfo>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<RoomCharInfo>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<_PVP_RANK_REFRESH_USER *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<_PVP_RANK_REFRESH_USER *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<_PVP_RANK_DATA *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<_PVP_RANK_DATA *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<_PVP_RANK_PACKED_DATA *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<_PVP_RANK_PACKED_DATA *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<_guild_member_refresh_data *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<_guild_member_refresh_data *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CHEAT_COMMAND>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CHEAT_COMMAND>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CryptoPP::ECPPoint>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CryptoPP::ECPPoint>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<GUILD_BATTLE::CGuildBattleRewardItem>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<GUILD_BATTLE::CGuildBattleRewardItem>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CLogTypeDBTask *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CLogTypeDBTask *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CRaceBuffInfoByHolyQuest *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CRaceBuffInfoByHolyQuest *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CRaceBuffInfoByHolyQuestfGroup *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CRaceBuffInfoByHolyQuestfGroup *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CMoveMapLimitRight *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CMoveMapLimitRight *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CMoveMapLimitRightInfo>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CMoveMapLimitRightInfo>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<int>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<int>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<char *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<char *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CMoveMapLimitInfo *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CMoveMapLimitInfo *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CUnmannedTraderGroupDivisionVersionInfo>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CUnmannedTraderGroupDivisionVersionInfo>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CUnmannedTraderRegistItemInfo>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CUnmannedTraderRegistItemInfo>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CUnmannedTraderUserInfo>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CUnmannedTraderUserInfo>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CUnmannedTraderSchedule>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CUnmannedTraderSchedule>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<TRC_AutoTrade *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<TRC_AutoTrade *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CUnmannedTraderDivisionInfo *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CUnmannedTraderDivisionInfo *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CUnmannedTraderClassInfo *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CUnmannedTraderClassInfo *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CUnmannedTraderSortType *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CUnmannedTraderSortType *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CUnmannedTraderSubClassInfo *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CUnmannedTraderSubClassInfo *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<CUnmannedTraderItemCodeInfo>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<CUnmannedTraderItemCodeInfo>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<RECV_DATA *>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<RECV_DATA *>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<RECV_DATA>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<RECV_DATA>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
#include "./common/ATFCore.hpp"
#include "std__allocator_detail.hpp"


START_ATF_NAMESPACE
    namespace registry
    {
        class std::allocator<AreaData>_registry : public IRegistry
        {
            public: virtual void registry() {
                auto& hook_core = CATFCore::get_instance();
                for (auto& r : std::detailstd::allocator<AreaData>_functions)
                    hook_core.reg_wrapper(r.pBind, r);
            }
        };
        
    }; // end namespace registry
END_ATF_NAMESPACE
